Ниже — максимально подробное описание **стека**, **как части проекта связаны между собой**, и **как запустить проект после клонирования с GitHub** (как у себя в редакторе, так и “для преподавателя” — максимально воспроизводимо).

---

## 1) Что это за проект и как он устроен логически

**ITAM** — веб-приложение для управления учебным процессом вокруг посещаемости:

* **Курсы** → внутри них **уроки**
* **Студенты** записаны на курсы
* По каждому уроку фиксируется **посещаемость** студентов
* По урокам/курсу собирается **фидбек**
* Есть **экспорт** (CSV/Excel и т. п. — по вашей реализации)
* Есть **аналитика** (агрегации/метрики)

С точки зрения архитектуры это классический вариант:

**Browser (UI) → Frontend (React) → HTTP API → Backend (FastAPI) → DB (SQLAlchemy) → Данные**

---

## 2) Технологический стек (что именно используется)

### 2.1 Frontend (клиент)

**React + TypeScript + Vite**

* React отвечает за компонентную архитектуру UI и рендеринг.
* TypeScript даёт строгую типизацию (модели данных, DTO, таблицы, формы).
* Vite — dev-сервер, сборка, быстрый HMR и прод-билд.

**UI библиотека: Ant Design**

* Компоненты форм (Form/Input), таблиц (Table), тегов (Tag), вкладок (Tabs), сообщений (Alert/notification), модальных окон и т. д.
* На практике это и даёт “админ-панельный” UX/визуальный уровень.

**Роутинг + запросы к API (типично)**

* Обычно используется React Router для страниц (`/login`, `/register`, `/courses`, `/lessons`, `/attendance`, `/feedback`, `/export`, `/profile`).
* Для запросов: `fetch` или `axios`.
* Авторизация: хранение токена (чаще `localStorage`) + подстановка `Authorization: Bearer <token>` в каждый запрос.

> Важно: даже если конкретные библиотеки роутинга/HTTP отличаются — принцип интеграции тот же.

---

### 2.2 Backend (сервер)

**FastAPI (Python)**

* REST API (эндпоинты) для: auth, users, courses, lessons, attendance, feedback, export, analytics.
* У вас это видно по структуре: `backend/app/api/v1/auth.py`, `courses.py`, `lessons.py`, `attendance.py`, `feedback.py`, `export.py`, `analytics.py`, `users.py`.

**ASGI-сервер: Uvicorn**

* Именно Uvicorn обычно запускает FastAPI-приложение (dev-режим с `--reload`).

**ORM и миграции**

* **SQLAlchemy** — слой доступа к БД (модели таблиц, сессии, запросы).
* **Alembic** — миграции схемы (создание/изменение таблиц через версионируемые миграции). Это критично, чтобы у всех открывалась одинаковая структура БД (и не было расхождений “у меня работает, у вас нет”). ([Uvicorn][1])

**Pydantic-схемы**

* DTO/схемы запросов-ответов (валидация входящих данных, формирование ответов).

**Auth: OAuth2 + JWT (типичный паттерн FastAPI)**

* Логин → backend выдаёт JWT токен → фронт отправляет его дальше как Bearer-токен.
* JWT стандартно описан как JSON Web Token.
* В FastAPI это обычно реализуется через `OAuth2PasswordBearer` и связанные зависимости.

**CORS**

* Чтобы фронт (например `http://localhost:5173`) мог ходить на API (например `http://localhost:8000`), на backend включают CORS middleware и разрешают нужные origins.

---

### 2.3 База данных

По вашим симптомам/ошибкам ранее у вас как минимум встречался **SQLite** (ошибка вида `sqlite3.OperationalError: no such column...`). Это нормально для учебного/демо-режима. В прод-режиме часто ставят PostgreSQL, но это уже зависит от вашей конфигурации.

Ключевой момент: **структура БД должна накатываться миграциями Alembic**, а не “как получится”.

---

### 2.4 DevOps / окружение

**Docker**

* У вас есть `backend/Dockerfile`, значит backend можно контейнеризировать.
* Для полного “поднятия” проекта обычно делают `docker compose` (frontend+backend+db), чтобы преподаватель мог одной командой стартануть. Команда `docker compose up` — стандартный способ поднять сервисы из compose-файла.

**Git / GitHub**

* Проект распространяется через репозиторий.
* Запуск “через GitHub” по сути означает: **клонирование** (`git clone`) → установка зависимостей → запуск.

**GitHub Actions**

* У вас есть `.github/workflows/publish-images.yml` — это про автоматизацию (например публикацию/обновление артефактов, картинок для README и т. п.). Документация по workflows относится к GitHub Actions.

---

## 3) Как всё “вместе работает” (пошаговый runtime-флоу)

### 3.1 Авторизация

1. Пользователь открывает **Login** (React + AntD форма).
2. Нажимает “Войти”.
3. Frontend делает `POST /api/v1/auth/login` (или аналогичный путь у вас).
4. Backend проверяет email/password:

   * сверяет хэш пароля
   * проверяет активность пользователя
5. Backend возвращает токен (JWT).
6. Frontend сохраняет токен и для следующих запросов шлёт:

   * `Authorization: Bearer <token>`

### 3.2 Дальше (пример: посещаемость)

1. UI страницы посещаемости запрашивает список курсов/уроков/студентов.
2. Backend отдаёт данные из БД через SQLAlchemy.
3. При добавлении отметок посещаемости UI отправляет `POST/PUT` на `/attendance`.
4. Backend валидирует данные (Pydantic), применяет RBAC/права (по роли), пишет в БД.

---

## 4) Запуск проекта после клонирования с GitHub (2 сценария)

Ниже я даю **два режима**:

* A) “Для разработчика” — локально (Python + Node)
* B) “Для преподавателя” — максимально воспроизводимо (Docker/Compose)

---

# A) Локальный запуск (без Docker)

## Шаг A0. Предварительные требования

Установить:

* Git
* Python 3.x
* Node.js (лучше LTS) + npm
* (опционально) Docker, если хотите второй сценарий

Проверка:

```bash
git --version
python --version
node -v
npm -v
```

---

## Шаг A1. Клонирование репозитория

```bash
git clone <URL_ВАШЕГО_РЕПОЗИТОРИЯ>
cd <ПАПКА_РЕПОЗИТОРИЯ>
```

Команда `git clone` — базовый способ получить копию репозитория локально.

---

## Шаг A2. Backend (FastAPI)

### A2.1 Создать виртуальное окружение

**Windows (PowerShell):**

```powershell
python -m venv .venv
.\.venv\Scripts\Activate.ps1
```

**macOS/Linux:**

```bash
python -m venv .venv
source .venv/bin/activate
```

### A2.2 Установить зависимости backend

Дальше зависит от того, как у вас оформлены зависимости:

**Вариант 1: requirements.txt**

```bash
pip install -r backend/requirements.txt
```

**Вариант 2: pyproject.toml / poetry**

```bash
cd backend
poetry install
cd ..
```

> Если вы не уверены, что именно у вас — ориентир простой: в репозитории либо есть `requirements.txt`, либо `pyproject.toml`.

### A2.3 Настроить переменные окружения

Обычно делается через `.env` (или переменные системы). В вашем случае логично искать настройки в:

* `backend/app/core/config.py`

Типичные переменные (пример):

* `DATABASE_URL=sqlite:///./app.db` **или** строка PostgreSQL
* `SECRET_KEY=...`
* `ACCESS_TOKEN_EXPIRE_MINUTES=...`
* `BACKEND_CORS_ORIGINS=http://localhost:5173`

CORS важен, чтобы фронт мог обращаться к API.

### A2.4 Накатить миграции (ОБЯЗАТЕЛЬНО)

Так вы избегаете ситуаций “нет колонки `role`” и т. п.

Команда уровня идеи:

```bash
cd backend
alembic upgrade head
cd ..
```

Alembic — стандартный инструмент миграций для SQLAlchemy. ([Uvicorn][1])

### A2.5 Запустить seed (если вам нужно демо-наполнение)

У вас фигурирует `seed.py`. Практически:

* если файл лежит в `backend/seed.py`:

  ```bash
  python backend/seed.py
  ```
* если в `backend/app/seed.py`:

  ```bash
  python backend/app/seed.py
  ```

> Точное место вы знаете по репозиторию; смысл: **seed запускается после миграций**, чтобы вставлять данные в уже существующую схему.

### A2.6 Запустить backend

Нужно знать модуль и имя переменной приложения. Обычно это `app = FastAPI()` в `backend/app/main.py`.

Команда выглядит так:

```bash
cd backend
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

Uvicorn — рекомендуемый ASGI-сервер для dev-запуска с `--reload`.

---

## Шаг A3. Frontend (React/Vite)

### A3.1 Установить зависимости

Перейдите в папку фронта (обычно `frontend/`):

```bash
cd frontend
npm install
```

### A3.2 Настроить API base URL

Для Vite обычно используется `.env` с переменными вида:

* `VITE_API_URL=http://localhost:8000`

Vite использует префикс `VITE_` для проброса env в клиент.

### A3.3 Запустить фронт

```bash
npm run dev
```

Vite поднимает dev-сервер (часто `http://localhost:5173`).

---

## Шаг A4. Проверка “живой связки”

* Открываете frontend URL.
* Регистрируетесь/логинитесь.
* Смотрите Network в DevTools:

  * запросы уходят на backend
  * backend отвечает 200/401/422 и т. п.

---

# B) Запуск “как у преподавателя” (через Docker)

Это лучший вариант, если вы хотите “запустил одной командой — и всё”.

## Вариант B1. Если у вас есть docker-compose.yml

Из корня репозитория:

```bash
docker compose up --build
```

Команда `docker compose up` — стандартный способ поднять стек сервисов.

Остановка:

```bash
docker compose down
```

## Вариант B2. Если compose пока нет, но есть Dockerfile для backend

Тогда backend можно собрать и запустить отдельно:

```bash
docker build -t itam-backend ./backend
docker run -p 8000:8000 itam-backend
```

А frontend запускать локально (или тоже контейнеризировать отдельным Dockerfile).

> Если вашей целью является “препод запускает без Node/Python”, то вам нужен **compose, который поднимает и backend, и frontend**, и (если нужно) DB.

---

## 5) Типовые проблемы и как быстро диагностировать

### 5.1 “Неверный email или пароль”, хотя вводите правильно

Это почти всегда одно из:

* вы логинитесь в пользователя, которого нет в БД (seed не запускали / другая БД)
* пароль не совпадает (в seed один, вы вводите другой)
* frontend смотрит не на тот backend URL

Что делать:

* проверьте, что **seed** реально выполнился без ошибок
* проверьте, что frontend ходит на тот же `host:port`, где поднят backend

### 5.2 Ошибка вида: `no such column: users.role`

Это **100% признак несинхрона схемы БД и моделей**:

* миграции не накатили
* или накатили не на ту БД (другая sqlite-база/другой путь)
* или старая база осталась от предыдущих попыток

Решение:

* `alembic upgrade head`
* при SQLite иногда проще удалить файл БД и заново: миграции → seed

### 5.3 CORS (в консоли браузера блокируются запросы)

Нужно:

* включить CORS middleware в FastAPI и разрешить origin фронта.

---

## 6) Как это красиво оформить в README (чтобы преподаватель “не думал”)

Структура раздела “Запуск” обычно такая:

1. **Requirements** (Git, Docker / или Git, Python, Node)
2. **Clone** (git clone)
3. **Run with Docker** (одна команда)
4. **Run locally** (backend, миграции, seed, frontend)
5. **Default accounts** (логины/пароли из seed)
6. **Troubleshooting** (3–5 самых частых проблем)

Если хочешь — я следующим сообщением могу собрать это уже в формате готового README-раздела “Stack & Run”, но мне тогда нужно только одно: **точные названия папок** (есть ли `frontend/`, как называется файл входа backend — `main.py` и где лежит `seed.py`). Без этого я уже дал “максимально близко к вашему проекту”, но финальный README можно сделать вообще без допущений.

[1]: https://www.uvicorn.org/?utm_source=chatgpt.com "Uvicorn"
